<?php
/**
 *
 * @package PhpbbWebsiteInterfaceBundle
 * @copyright (c) 2014 phpBB Group
 * @license http://opensource.org/licenses/gpl-3.0.php GNU General Public License v3
 * @author MichaelC
 *
 */

namespace Phpbb\WebsiteInterfaceBundle\Utilities;

use Symfony\Component\Config\FileLocator;

class DownloadManager
{
	protected $branch;
	protected $selectedVersion;
	protected $update;
	protected $packages;
	protected $fromVersions;
	protected $kernel;
	protected $cache;

	public function __construct($kernel, $cache)
	{
		$this->kernel = $kernel;
		$this->cache = $cache;
	}

	public function setBranch($branch)
	{
		$this->branch = $branch;

		return;
	}

	public function setUpdate($selectedVersion)
	{
		$this->selectedVersion = $selectedVersion;
		$this->update = true;

		return;
	}

	public function getAvailableUpdateFromVersions()
	{
		return $this->fromVersions;
	}

	public function generatePackages()
	{
		return $this->packages;
	}

	private function getPackages()
	{
		if ($this->cache->contains('packages_json_downloads') !== FALSE)
		{
			// If we have it in cache, get the packages.json file
			$packagesDataJson = $this->cache->fetch('packages_json_downloads');
			$cacheStatus = 'Hit';
		}
		else
		{
			// If we don't have it in cache, find it & load it
			$locator = new FileLocator($this->kernel->getRootDir());
			$jsonFile = $locator->locate('packages.json', null, true);
			$packagesDataJson = $jsonFile->getContents();
			$this->cache->save('packages_json_downloads', $packagesDataJson, 3600);
			$cacheStatus = 'Miss';
		}

		// Parse JSON response and discard irrelevant branches
		$packagesData = json_decode($packagesDataJson, true);
		$relevantPackages = $packagesData[$branch];

		// Latest release in this branch is...
		$release = $relevantPackages['release'];

		// Link to the packages for this release. Add filenames on here for download urls.
		$download_base_link = 'https://download.phpbb.com/pub/release/' . $this->branch . '/' . $release . '/';

		// If we haven't established it's an update (and have an update from version)
		if (!$update)
		{
			// Discard irrlevant data
			$packages = array(
				'package' => $relevantPackages['package']['release'],
				'patch' => $relevantPackages['updates']['patch'],
				'changed-files' => $relevantPackages['updates']['changed-files'],
			);

			$hashCaches = 0;
			$packagesTotal = 0;

			foreach ($packages as $package)
			{
				// URL to this specific package
				$url = $download_base_link . $package['filename'];

				// Generate sha256/md5 hashes for packages
				$hash = gethash($packages[$package]['filename'], $url);

				// Make use of the stuff we just generated by putting it back in ready for templates
				$packages[$package]['url'] = $url;
				$packages[$package]['hash'] = $hash['hash'];
				$packages[$package]['hash'] = $hash['hashType'];

				// Counts
				$packagesTotal++;
				($hash['hashCacheStatus'] == 'Hit') ? $hashCaches++ : null;
			}
		}

		return array($packages, array($cacheStatus, $hashCaches));
	}

	/**
	 * Get the MD5 or SHA256 hash
	 *
	 * @param  string $packageName  Package Filename
	 * @param  string $url          Url to the package
	 * @return array 				hash, hashType (md5 or sha356), hashCacheStatus (Hit or Miss)
	 */
	private function getHash($packageName, $url)
	{
		$cacheName = 'packages_hash' . $packageName;
		$hashType = ($this->branch == '3.0') ? 'md5' : 'sha256';

		if ($this->cache->contains($cacheName) !== FALSE)
		{
			// See if we've cached the hash before grabbing an external file
			$hash = $this->cache->fetch($cacheName);
			$hashCacheStatus = 'Hit';
		}
		else
		{
			// It seems we have no choice, grab the file from the external server
			$hash = @file_get_contents($url . '.' . $hashType);
			$this->cache->save($cacheName, $hash, 3600);
			$hashCacheStatus = 'Miss';
		}

		return array(
			'hash' => $hash,
			'hashType' => $hashType,
			'hashCacheStatus' => $hashCacheStatus
		);
	}
}
